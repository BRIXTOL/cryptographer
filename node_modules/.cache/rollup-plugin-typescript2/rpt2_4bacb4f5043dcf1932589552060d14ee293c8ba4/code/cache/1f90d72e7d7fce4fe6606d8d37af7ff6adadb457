{"code":"import { createHash, createDecipheriv, createCipheriv, getHashes } from 'crypto';\r\n/**\r\n * Creates hash of an string based on available hashes of platform\r\n */\r\nconst hash = (input, hash = 'md5') => {\r\n    if (getHashes().indexOf(hash) !== -1) {\r\n        return createHash(hash).update(input).digest('hex');\r\n    }\r\n    throw new Error('hash ' + hash + ' not found in your platform');\r\n};\r\n/**\r\n * Generate IV\r\n */\r\nconst iv = (key, length = 16) => key.substring(length);\r\n/**\r\n * Normalize string\r\n */\r\nconst normalizeInput = (input) => {\r\n    if (input === null || typeof input === 'undefined') {\r\n        throw new Error('required origin');\r\n    }\r\n    if (typeof input === 'object') {\r\n        input = JSON.stringify(input);\r\n    }\r\n    if (typeof input !== 'string') {\r\n        input = input.toString();\r\n    }\r\n    return input;\r\n};\r\n/**\r\n * If is JSON string then parse, else just return\r\n */\r\nconst normalizeOutput = (input) => {\r\n    try {\r\n        return JSON.parse(input);\r\n    }\r\n    catch (e) {\r\n        return input;\r\n    }\r\n};\r\n/**\r\n * Encode string\r\n */\r\nfunction encode(input) {\r\n    input = normalizeInput(input);\r\n    const cipher = createCipheriv(this.algorithm, this.key, this.iv, this.options);\r\n    return cipher.update(input, 'utf8', 'hex') + cipher.final('hex');\r\n}\r\n/**\r\n * Decode string\r\n */\r\nfunction decode(input) {\r\n    input = normalizeInput(input);\r\n    const decipher = createDecipheriv(this.algorithm, this.key, this.iv, this.options);\r\n    const decoded = decipher.update(input, 'hex', 'utf8') + decipher.final('utf8');\r\n    return normalizeOutput(decoded);\r\n}\r\n/**\r\n * Cryptographer\r\n */\r\nexport function Cryptographer(secret, algorithm, options) {\r\n    if (typeof algorithm === 'undefined')\r\n        algorithm = 'aes-256-ctr';\r\n    const state = {};\r\n    const algorithms = [\r\n        'aes-256-cbc',\r\n        'aes-256-cbc-hmac-sha1',\r\n        'aes-256-cbc-hmac-sha256',\r\n        'aes-256-cfb',\r\n        'aes-256-cfb1',\r\n        'aes-256-cfb8',\r\n        'aes-256-ctr',\r\n        'aes-256-ofb',\r\n        'aes256',\r\n        'camellia-256-cbc',\r\n        'camellia-256-cfb',\r\n        'camellia-256-cfb1',\r\n        'camellia-256-cfb8',\r\n        'camellia-256-ofb',\r\n        'camellia256'\r\n    ];\r\n    if (typeof secret !== 'string' || secret === '') {\r\n        throw new Error('required an string key');\r\n    }\r\n    if (algorithm !== 'aes-256-ctr' && algorithms.indexOf(algorithm) < 0) {\r\n        throw new Error(`\"${algorithm}\" is not supported`);\r\n    }\r\n    state.algorithm = algorithm;\r\n    state.key = hash(secret);\r\n    state.iv = iv(state.key);\r\n    state.options = options;\r\n    return {\r\n        encode: encode.bind(state),\r\n        decode: decode.bind(state)\r\n    };\r\n}\r\n;\r\n","references":[],"dts":{"name":"/Users/Panoply/Sites/brixtol/serverless/packages/cryptographer/node_modules/.cache/rollup-plugin-typescript2/placeholder/index.d.ts","writeByteOrderMark":false,"text":"/// <reference types=\"node\" />\r\nimport { CipherCCMOptions } from 'crypto';\r\nexport declare type Algorithm = ('aes-256-cbc' | 'aes-256-cbc-hmac-sha1' | 'aes-256-cbc-hmac-sha256' | 'aes-256-cfb' | 'aes-256-cfb1' | 'aes-256-cfb8' | 'aes-256-ctr' | 'aes-256-ofb' | 'aes256' | 'camellia-256-cbc' | 'camellia-256-cfb' | 'camellia-256-cfb1' | 'camellia-256-cfb8' | 'camellia-256-ofb' | 'camellia256');\r\nexport declare type Data = string | object | string[] | object[] | number;\r\n/**\r\n * Cryptographer\r\n */\r\nexport declare function Cryptographer(secret: string, algorithm?: Algorithm, options?: CipherCCMOptions): {\r\n    encode: any;\r\n    decode: any;\r\n};\r\n"}}
